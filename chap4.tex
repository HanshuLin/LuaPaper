\chapter{Operational semantics for Featherweight Lua} \label{chp: syntax and semantic}
%NEED A PARA?

\section{Syntax for Featherweight Lua}\label{sec: FWLUAsyntax}
Expressions and statements are basic elements forming FWLua externally. What is more, we have just introduced the core part such as functions and metatables, which could form the internal work of FWLua. We now give the complete syntax of FWLua, including the function and metatables. In this section, we will specifically introduce the syntax in section \ref{sec: FWLUAsyntax} and the full version of semantic in section \ref{sec: FWLUAsemantic}.

We have given some figures showing the syntax of expressions and statements separately, and have introduced them in detail before. What is more, integrating them would not be so hard now, since we have functions as a bridge. Originally, the reason we split them is because statements will not return any value after being evaluated, while expressions always return a value as results. Therefore, we will pretend that statements will always return a value just like expressions, and will treat it as a kind of ``cheating''. However, in solving this issue, we just make those values statements return sort of nonsense.

The full syntax of Featherweight Lua is given by Figure \ref{fig:FW2Syx}. We can see that there are both old version expressions such like constants and binary operations, and statements. In the aspect of expression, what we remain the same would be register, constant and new allocation. We change the table select {\tt e\textsubscript{1}[e\textsubscript{2}]} into some raw function {\tt rawget(e\textsubscript{1},e\textsubscript{2})}, which e\textsubscript{1} is the table and e\textsubscript{2} is the key in that table. It is highly because there are some rules, or we can call them``hooks'', in the expressions of table select since we have introduced metatable. Talking about statements, a set of hooks also exists in the table assignment statements. So we just change the syntax of assignment statements during the integrating to also a raw function {\tt rawset(e\textsubscript{1},e\textsubscript{2},e\textsubscript{3})}, while e\textsubscript{1} also means the table, e\textsubscript{2} means the key and the e\textsubscript{3} means the value that we want to assign. 

In addition, we add syntax of function finally, that is {\tt function x return e end} with only one argument {\tt x} and body of function {\tt e}. However, since the function is mostly like lambda calculus, we will use the symbol $\lambda$ for a simpler syntax represention to make it easier to read. In other words, the syntax ``{\tt $\lambda$x.e}'' means ``{\tt function x return e end}'' in FWLua. We define it as the function abstraction being used as function definition for the reasons we have mentioned before. 

Also, there is the syntax of function application, and the structure is pretty simple: {\tt e\textsubscript{1}(e\textsubscript{2})}, which e\textsubscript{1} presents the name of function and e\textsubscript{1} means the value this function applies. Since we have integrated statements and expressions, functions now is easy too add. In other words, we don't need to decide weather it belongs to statements or expression due to its task.

One final thing to mention, there would not be any Boolean value in constants. Because functions are similar to lambda calculus, the value of true and false can be transferred to some specific functions based on the lambda calculus. The reference\cite{LC} has mainly talked about what these functions look like.

% ----------------------------[FW2.2][SYNTAX]-----------------------------
\begin{figure}
\caption{Full Syntax of Featherweight Lua}
\label{fig:FW2Syx}
\[
  \begin{array}{llr}
  \mydefhead{e ::=\qquad\qquad\qquad\qquad}{Expressions}
  \mydefcase{a}{register}
  \mydefcase{c}{constant}
  \mydefcase{\{\}}{new allocation}
  \mydefcase{{\tt rawget}(e_1,e_2)}{table select}
  \mydefcase{{\tt rawset}(e_1,e_2,e_3)}{table update}
  \mydefcase{e ~{\tt binop}~ e}{binary operation}
  \mydefcase{\aFunction{x}{e}}{abstraction}
  \mydefcase{(e)(e)}{function application}
  \\
  \\
  \mydefhead{c ::=\qquad\qquad\qquad\qquad}{Constants}
  \mydefcase{i}{integer}
  \mydefcase{s}{string}
  \mydefcase{nil}{nil value}
  \\
  \mydefhead{a \qquad\qquad\qquad\qquad}{Registers}
  \mydefhead{x \qquad\qquad\qquad\qquad}{Variables}
  \\
    op ::= & + ~|~ - ~|~ * ~|~ / ~|~ .. ~|~ > ~|~ >= ~|~ < ~|~ <= ~|\quad& \mbox{\emph{Binary operators}} \\
  \quad & ~ == ~|~ ~= ~|~ and ~|~ or &\\
\end{array}
\]
\end{figure}

\section{Semantics for Featherweight Lua}\label{sec: FWLUAsemantic}
Consequently, The full big-step semantic of Featherweight Lua (evaluation rules) shows by Figure \ref{fig:FW2.1Sem}. This semantic is totally based on the syntax we introduced above. In the semantic, there are 5 kinds of runtime variables: store, table, function, value, and name. The variable ``store'' means the basic store in the runtime of FWLua. Actually, it is a table mapping register and table. Since we have mentioned that table is the primary data structure in FWLua, all tables will be stored in the store with specific addresses, which are also ``register''. Secondary, the variable ``table'' is the table like store but only maps keys and values. ``Function'' is used as functions. The variable ``value'' means all types of values in FWLua. There is also a variable called ``name'' to represent some names using strings.

In the basic evaluation rule, we can see that FWLua takes current expressions and store before evaluating and will return a value and manipulated store when it is done. Basically in Lua, expressions return values and most of statements change the store. Here we just pretend that all new expressions, including expressions and statements in Lua, will return a value and change the store. Next we will discuss every single rule in detail.

{\bf FW-VALUE}: It takes the value and return it, just like nothing happen. We can get that values would be our final results. In other means, there is no need to change anything when the executer meets a fixed value since it is executing using some recursive functions. 

{\bf FW-NEW}: The semantic NEW means allocating a new memory location in the store to a new table {\tt \{\}}. Therefore, an address has to be allocated when we meet the token of NEW. In addition, we add a checking phase to ensure that if the address we want to allocate is been occupied or not. Then, we will add this table to the store (register to table), with the key of new address, and return this address as the value.

{\bf FW-RAWGET}: The evaluation rule of {\tt rawget()} could be pretty straight forward. Since we just treat getting variable as some function, we now have to evaluate the arguments in this function as the first step. After that, we will get the values about both key and table. The executer then will find the table in the store based on the name of table and thus find the value with the key in the table. Obviously this rule will return the value that users want to get and thus manipulate the store.

{\bf FW-RAWSET}: {\tt rawset()} is part of similar as {\tt rawget()}: it will evaluate its 3 arguments in the body and return them as table, key and value at the first step and then attempt to find that table in the store as the second step. The difference is that the executer then will add the pair with key and value into this table if this table exists in the store. Since Lua merges variable declaration and assignment statement into one, {\tt rawset()} now can represent both as user needs: once the key in rawset function has already existed in the table, it will automatically update it.

{\bf FW-BINOP}: There are 3 different evaluation rules bringing binary operations in FWLua: {\it RAW}, {\it LEFT} and {\it RIGHT}. Because metatables can define new behavior against binary operators, values in binary operations are no more only numbers. Therefore, the rules {\it LEFT} and {\it RIGHT} evaluate values in the left hand side (or the right hand side) to a table in binary operations. What is more, binary operators in the rules {\it LEFT} and {\it RIGHT} are treated as functions.
%For example, multiple and division operations will be always computed before augment and minor operations, and there are still many examples like this in binary operations. All in all, the concepts of these rules are similar: it evaluates expressions on each side of operation symbol and then computes them using reserved functions in the metatable. Finally it returns the value and modifies the store. 

{\bf FW-FUNC-CALL}: This rule evaluates a function application in FWLua. At the beginning, it evaluates the function name and returns the expression with format of function body. Then it evaluates the value this function applies. Finally, it will evaluate the function body with the substitution from arguments to values. 


% -------------------------------[FW2.1][SEMANTIC]--------------------------------
\newcommand{\metaSemanticFull}[6]{{#1}, {#2}, {#3} \Downarrow {#4}, {#5}, {#6}}
\newcommand{\ssrule}[3]{
  \rel{#1} &
  \frac{\strut\begin{array}{@{}c@{}} #2 \end{array}}
       {\strut\begin{array}{@{}c@{}} #3 \end{array}}
   \\~\\
}
\begin{figure}[P]
\caption{Semantics: Featherweight Lua With Metatables and Metamethods}
{\bf Runtime Syntax:}
\label{fig:FW2.1Sem}
\[
\begin{array}{rclcl}
  \sigma & \in & {Store} \quad  & = & \quad {register} ~\rightarrow ~{table} \\
  T & \in & {Table} \quad  & = & \quad {string} ~\rightarrow ~{value} \\
  f & \in & {Function} \quad & ::= & \quad function \\
  v & \in & {Value} \quad & ::= & \quad constant~|~ register ~|~ f~ \\
  x & \in & {Name} \quad & ::= & \quad string 
  \\
\end{array}
\]

{\bf Evaluation Rules:~~~ \fbox{$\semanticFull {e}{\sigma}{v}{\sigma'}$}} \\
\[
\begin{array}{r@{\qquad\qquad}c}
\ssrule{FW-VALUE}{
}{
  \semanticFull {v}{\sigma} {v}{\sigma}
}
\ssrule{FW-NEW}{
  a \notin dom(\sigma)\\
  \sigma' = \sigma + (a := \{\})
}{
  \semanticFull {\{\}} {\sigma}   {a} {\sigma'}
}

\ssrule{FW-RAWGET}{
  \semanticFull{e_1}  {\sigma}    {a}  {\sigma_1} \quad
  \semanticFull{e_2}  {\sigma_1}    {s}  {\sigma'} \\
  T = \sigma'(a)\quad
  v = T(s)\\
  
}{
  \semanticFull {{\tt rawget}(e_1,e_2)} {\sigma}   {v} {\sigma'}
}
\ssrule{FW-RAWSET}{
  \semanticFull{e_1}{\sigma}{a}{\sigma_1} \quad
  \semanticFull{e_2}{\sigma_1}{s}{\sigma_2} \quad
  \semanticFull{e_3}{\sigma_2}{v}{\sigma_3} \\
  T = \sigma_3[a] \quad
  T' = T~+~(s := v) \\
  \sigma' = \sigma_3[a:=T']
}{
  \semanticFull{{\tt rawset}(e_1,e_2,e_3)}{\sigma}{a}{\sigma'}
}
\ssrule{FW-BINOP-RAW}{
  \semanticFull{e_1}{\sigma}{v_1}{\sigma_1} \quad
  \semanticFull{e_2}{\sigma_1}{v_2}{\sigma'} \\
  v = v_1 ~op~ v_2
}{
  \semanticFull{e_1 ~op~ e_2}{\sigma}{v}{\sigma'}
}
\ssrule{FW-BINOP-LEFT}{
  \semanticFull{e_1}{\sigma}{T}{\sigma_1} \quad
  \semanticFull{e_2}{\sigma_1}{v_1}{\sigma_2} \\
  m = T[{\tt ``{\_}MT"}]\quad
  f = m[{\tt translate}(op)]\\
   \semanticFull{(f(T))(v_1)}  {\sigma_2}    {v_2} {\sigma'} \\
}{
  \semanticFull{e_1 ~op~ e_2}{\sigma}{v_2}{\sigma'}
}
\ssrule{FW-BINOP-RIGHT}{
  \semanticFull{e_1}{\sigma}{v}{\sigma_1} \quad
  \semanticFull{e_2}{\sigma_1}{T}{\sigma_2} \\
  m = T[{\tt ``{\_}MT"}]\quad
  f = m[{\tt translate}(op)]\\
   \semanticFull{(f(v))(T)}  {\sigma_2}    {v} {\sigma'} \\
}{
  \semanticFull{e_1 ~op~ e_2}{\sigma}{v}{\sigma'}
}
\ssrule{FW-FUNC-CALL}{
  \semanticFull{e_1}{\sigma}{\aFunction{x}{e}}{\sigma_1} \\
  \semanticFull{e_2}{\sigma_1}{v_1}{\sigma_2} \\
  \semanticFull{e[x:=v_1]}{\sigma_2}{v}{\sigma'} 
}{
  \semanticFull{(e_1)(e_2)}{\sigma}{v}{\sigma'} 
}
\end{array}
\]
\end{figure}
