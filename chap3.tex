\chapter{Featherweight Lua}
Although Lua has a minimal syntax compared to most other programming languages, it is still too complex for formal reasoning. Therefore, to make it simpler for reading and analyzing, we further simplify the syntax from the full version Lua. We call the new, simplified language {\it Featherweight Lua} (FWLua). In FWLua, we remove unnecessary syntax and reduce the language to its essential core.

%--------------------------MODIFIED by HANSHU--------------------------
In this chapter, we first introduce several primary parts in Lua --- expressions and statements, which can be simplified to FWLua in a straightforward way. Then, we are going to talk about functions and metatables, which are both key elements of Lua, in more detail in the chapter. Meanwhile, we will also give the full syntax and evaluation rules after all the elements in FWLua have been specifically introduced.
%-----------------------------------------------------------------------

\section{Expressions}
%--------------------------MODIFIED by HANSHU--------------------------
Lua splits statements and expressions, though they overlap because of functions and function application. As the consequence, we merge expressions and statements, and treat both of them as expressions in FWLua. In this section, therefore, we discuss our expressions in FWLua and why we think these simplifications remain true to the spirit of Lua. 
%----------------------------------------------------------------------

\subsection{Lua's Expressions}

We keep constant values in the language.
%It is because that the final purpose of every expression is returned as a value by evaluations.
These types include Number, String and Boolean representing values in the original syntax.
%It is very obvious that these types are all constants, which means that nothing would be changed after only this type of expression is evaluated, just like a final result in every programs. Therefore, we distract those constants, treat them as a basic part that doesn’t change anything, and give them a new name called ``Constant''.
%
There is also a special expression {\tt nil}, similar to {\tt null} in Java and to both {\tt null} and {\tt undefined} in JavaScript.
%which is equivalent to both ``null'' and `0' in Java. % This does not appear to be true.  Nil + 1 is not 1.
%The thing we care is the result that it returns--nothing. That is the reason that we include it to the constant part.
For simplicity, we treat {\tt nil} as a constant in our evaluation rules.

%The second one we choose to merge is about getting variable, including mutable variables and constants.
In the original syntax,
%variable is a separated part that belongs to expression, for the reason that
there are several different ways for getting variables.
To make it concrete, we show a program using all three ways for getting variables:

\begin{verbatim}
tbl
tbl.x
tbl["y"]
\end{verbatim}

%There is an expression of getting variable in the left side of `=' in each statement.
The first case references a variable name.
%as a key, and it will return the value map to this key in the current scope.
The second is a direct table select, using `.'.
This variable expression directly gets the value referenced by the key ``x'' in the specified table ``tbl''.
The last case is an example of a computed table access.
It is similar to the second case, except that Lua allows an expression to dynamically determine the key in the table.
%which means that we can define a key in the table only by a variable, such like {\tt tbl[x]}. The executer evaluates the variable `x’ and then returns its value at first.

%In addition, we find that there is a reserved word already in Lua called ``\_ENV''. This word means the global table in Lua, since it only provides one data structure called ``table''. By knowing this, we can then merge all the three variable statements since the first case we mentioned above can be transferred in some way using reserved words in Lua.
The computed table access case can simulate the other approaches.
Referring to {\tt tbl.x} is identical to {\tt tbl['x']}.
There is also a global table in Lua, which can be referred to by the {\tt \_ENV} variable.
Therefore, instead of referring to {\tt x}, we can use {\tt \_ENV.x}.

As a consequence, variables are now represented by a more common format: e\textsubscript{1}[e\textsubscript{2}], which we also call table select. In this format, we only look up the variable e\textsubscript{2} in the table e\textsubscript{1} and return the value (or nil if it doesn't exist). And we can use reserved word ``\_ENV'' to represent the global table. Specifically,

\begin{verbatim}
tbl
\end{verbatim}
is equal to
\begin{verbatim}
_ENV["tbl"]
\end{verbatim}

%What is more, one interesting and complicated construction in expression is Table Constructor.
Table constructors
%could be no different as a constant, but the purpose is constructing
construct a new domain with some scoped mutable variables within.
%Therefore, we distract the symbol ``\{\}'' out of constants. In this case,
When we invoke ``\{\}'', the compiler allocates a new scope
and creates a new anonymous table, similar to how {\tt new} works in JavaScript.

%We also find that there the
Lua supports both
unary operators and binary operators, though it is straightforward to treat unary operators as binary operators
with two expressions e\textsubscript{1} and e\textsubscript{2} where e\textsubscript{1} is {\tt nil}.
As a result, we eliminate unary operators from the syntax of FWLua.
%Then, every time we meet a unary operation expression again, we will

%Since new binary operation syntax is found and we want to make our syntax cleaner, we also remove the portion named prefix expressions. There are some high-priority expressions in the syntax of prefix expressions such like function calls. Consequently, we give them the same priority by desugaring them in FWLua.

The syntax of expressions in Featherweight Lua is presented in Figure~\ref{fig:FWLuaExp}.
%This syntax captures a more subtle syntax about original Lua Expression.
%In FWLua, we desugar the prefix expression, since it is just an expression with parentheses.
%Since this is just a start of the project, we remove all stuffs related to function to make it simpler. Apparently, we will not abandon functions since we all know it is the most important part in a programming language. We will add it and mainly talk about it in the following chapter. Therefore, the expression syntax we give so far is very basic and simple compare to full version Lua, only with a set of operations about handling values and variables.


\subsection{Lua's Statements}
According to Roberto Ierusalimschy~\cite{PIL},
%there is supposed to be some principles which statements provide:
statements in Lua include assignment, control structures, function calls, and variable declarations.

Our strategy for simplifying statements is to group our syntactic forms by each fundamental type of operation and then choose one syntactic form for each group.
We also remove blocks from our syntax since we can desugar sequences of statements easily.

We first discuss assignment statements.
Every assignment statement changes the store. Based on this, we can merge all types of assignment statements into one single form. According to the original syntax, there might be some differences in local assignment statements.
%FiXME: Show an example so that it is clear what you are talking about with multiple assignments in one statement.
There is also a form of assignment that allows using a list of expressions as either variables or values to complete multiple assignments in one statement. However, we choose the basic assignment form without lists or local scope.  The other forms can be produced with syntactic sugar.
In Chapter~\ref{chp:luaTranslation} we review the desugaring process in more depth.

%FIXME: list a couple of example control structures.
Lua also features a large number of control structures.
However, these can be represented with functions,
following patterns established for the lambda calculus~\cite{TAPL}.
Therefore, we eliminate these statements from FWLua.



\section{Integration}
Finally, we treat every statement as an expression for simplicity in FWLua.
However, this means that FWLua is not a true subset of Lua.
Consider the following expressions:

\begin{verbatim}
3;   //A constant value
x;   //A variable
a = b = 10;   //Multiple statements
\end{verbatim}

Lua does not allow constants or variables as stand-alone statements,
and chained assignments are not supported in Lua.
While these are departures from Lua, we feel that they are minor discrepancies between the languages. In addition, Chapter \ref{chp: syntax and semantic} mainly talks about the syntax and semantics of FWLua.



\section{Functions}
Functions are used to complete a set of computations and return a value.
To define a function in Lua, each of the following statements can be used:
\begin{verbatim}
function foo(x) x = x + 1 return x end    --normal function definition
foo = function (x) x = x + 1 return x end --using anonymous function
\end{verbatim}
We can invoke this function as follows:
\begin{verbatim}
foo(4);
\end{verbatim}
In addition, functions in the full version of Lua provide multiple expressions in the function, both in defining arguments and returning values. For example:
\begin{verbatim}
function add(x, y)
  local i = x + y;
  return i;
end
\end{verbatim}
and also:
\begin{verbatim}
function inc(x, y)
  x = x + 1;
  y = y + 1;
  return (x,y);
end
\end{verbatim}
We can see that a function can both take more than one argument and return multiple values.

However, we want to keep the syntax for FWLua as simple as we can. Therefore, we represent multiple expressions through desugaring, which we discuss later in this chapter.

Based on the examples above, we then choose to use the syntax of anonymous functions as our primary function syntax in FWLua. Since we have already come up with the syntax of assignment statements, we will combine it with anonymous function definition to define a function with a name. Besides, we restrict functions to one argument and one return value for decreasing unnecessary complexity in the syntax.

However, we have also raised the issue against one special statement called ``return statements''. As we mentioned above, return statements cannot really be called statements. Although Lua allows it appear individually like statements, return statements can only appear as the last statement in a block, and that is the reason why we need to treat them as a special cases in functions. In solving this issue, we decide to make the reserved word {\tt return} as the tail in the function and will use {\tt return nil} instead of no return statement in the block.

As the result, the syntax of function would be like the following:
\begin{verbatim}
function x return e end
\end{verbatim}
In the syntax, {\tt x} represents the argument a function takes (only one allowed), and {\tt e} represents the function body. Functions in FWLua still allow multiple expressions in the body of function through desugaring, outlined in Chapter~\ref{chp:luaTranslation}.
%But it would be better combining with the function in function. After complete the syntax of function, we can say that there would be many syntactic sugars in the full version of Lua now can be represented in FWLua using the function. We will talk about it in detail in the chapter 5. 

We will talk about some key factors related to the function in following sections. Following with these sections, we use some examples to make them easier to comprehend.

\subsection{Closures}
Before talking about closures in Lua and FWLua, we will show some examples to help understand closures in functions.
\begin{verbatim}
x=42
function foo()
  print(x)
end
function bar()
  local x=100
  foo()
end
bar() --will print 42
\end{verbatim}
In the above example, a local variable is used in the function {\tt bar()}. Meanwhile, there is also a global variable as the same name in the program. Also we have another function {\tt foo()} and we will get the variable and print it in this function. Finally, we take the function {\tt foo()} as the nested function {\tt bar()}, and within it we print the only name of variable to testify if there is some scope in every function. And then we can see that the result of the program would return {\tt 42}.

%FIXME: This does not seem true.  Consider:
%  function foo()
%  local x = 10;
%  return function() return x + 1; end;
%  end
%  bar = foo();
%  print(bar())
In Lua, there is a special restriction for functions about the scope according to our research \ref{LuaScoping}. The fact is that even nested functions in the function would have completely no right for accessing local variables in that function. Actually, this fact applies to any function in Lua. The purpose of briefly introducing closures in Lua is that FWLua may be too simple that it cannot provide closures like Lua. Therefore, we will mainly discuss about how to implement the full closure like Lua using syntactic desugaring
%FIXME: DON'T HARDCODE CHAPTER NUMBERS!!!  Use refs.
in chapter 5. 


\subsection{Recursion}\label{sec:recursions}

Recursion means that a function can call itself in its body.
%Basically, recursion would be used in solving problems those need to also be defined in them, for example, the factorial function.
Here, we give an example of a recursive function in Lua, {\tt factorial(n)}.

\begin{verbatim}
function factorial(n)
  if n == 0 then
    return 1;
  else
    return n * factorial(n-1);
  end
end

print(factorial(5)); --results 120
\end{verbatim}

In the example, we can see that only defining the function {\tt factorial(n)} is not simply enough. For implementing the factorial, it must be called with different argument in the body of itself, and this would be the classic recursive function.

Lua uses a call stack to store local variables in one function, and thus implement recursive functions~\cite{begLua}. Theoretically, when a function itself is called in its body, the interpreter will automatically treat it as just a variable and will further finish it after the function is done. In other words, multiple calls to the same function can be active at the same time without the crashes reporting ``undefined'' in Lua.

This quality in Lua is very helpful for us to give the further abstract syntax in FWLua about function, since functions in FWLua would be more like lambda calculus. Next, we will briefly introduce lambda calculus and a key factor for the recursion in lambda calculus called the fix combinator.

\subsection{Lambda calculus}
The restriction of allowing a function in FWLua to only take one argument comes from the lambda calculus. The method of lambda calculus is a formal algorithm representing computations based on functions. Function abstraction and function application are the two main parts in the syntax of lambda calculus. 

%FIXME: We need to tweak the discussion of lambda calculus a bit.  Let's discuss in person.
There are several advantages using lambda calculus. One of the advantages is that lambda calculus is very clear for representing the computation using its own system of symbols, since this system is very easy to write and understand. In the very basic lambda calculus, the symbol `$\lambda$' means a function, the letter appears after `$\lambda$' means the argument this function takes.
Actually, these two letters form the basic called function.
Besides, lambda calculus uses another expression as the body of function to form the function abstraction. What is more, in representing a function application, there is also an extra letter behind the function abstraction meaning ``the perimeter this function applies''. We can represent functions in FWLua using lambda calculus. For instance, the function call in FWLua:
\begin{verbatim}
(function(x) return x end)(a)
\end{verbatim}
can be represented as a function application ({\tt $\lambda$x.x a}) using lambda calculus. In the example, the expression {\tt $\lambda$x.x} means the function abstraction, taking argument {\tt x} and returning {\tt x} as the result. Furthermore, the letter {\tt a} shows the variable that this function applies.

Therefore, it obviously proves the reason why we let only one argument in the function. However, functions with multiple arguments in Lua would be inevitable. Lambda calculus also gives the solution about this. Based on the syntax, the function taking 2 arguments ({\tt x} and {\tt y}) can be shown as {\tt $\lambda$x.$\lambda$y.y}. We will further talk about how we do the syntactic desugaring according to the basic lambda calculus.

\newcommand{\abFunction}[2]{{\tt function} ~{#1}~{\tt return}~{#2}~{\tt end}}
\newcommand{\semanticFullRaw}[4]{{#1},{#2} \Downarrow {#3},{#4}}
\newcommand{\semanticFull}[4]{{#1},{#2} \Downarrow {#3}, {#4}}


\section{Metatables and Metamethods}
Metatables allow us to define behaviors as fallbacks when Lua cannot handle the comming operations. These operations even include symbols those we think is absolutely fixed, such as ``+'' or ``-''.

Also, metamethods in metatables can be automatically invoked once the relative conditions are satisfied. In other word, the behaviors of tables can be further controlled to follow our new rules in the program by using metatables. That is the reason why metatables are so unique in FWLua.
%We even think them as a connection between the full version of Lua and FWLua because they will possibly contribute a lot to desugaring phase.

Same as Lua, there are totally two types of metatables in FWLua: the global metatable and table metatables. Basically, the default of these two tables will not be so different. We will use global metatable to control behaviors for values and put it as a reserved table in the global store, since all values in the full version of Lua only have one associated metatable. Also, we can predefine the table metatable, but it will only be available once a new table is created. This will match the truth that every table in Lua has its own metatable.

Finally, there are two reserved functions we need to mention: {\tt setmetatable()} and {\tt getmetatable()}. These two functions are used for setting and getting a metatable of a value/table. %Actually we will use them commonly in the phase of transfer Lua to FWLua, obviously because that FWLua has much simpler syntax and structure than the full version of Lua.
%FIXME: Not sure I understand this part -- let's discuss.
Lua only allows to set a user defined table as a metatable, and need C code to manipulate the metatables using other types. However, we will skip studying this and only allow the former condition in FWLua.

\subsection{Metamethods}
Metamethods are reserved functions with a set of special names in a metatable. These functions can be automatically triggered, hence they are called ``hooks''. Actually, all the computations during programming can be thought as hidden functions. One of the purposes of metamethods is to let developers change the behavior of the programming language to a certain degree.

Furthermore, there are 4 different kinds of metamethods in Lua: arithmetic, relational, library-defined, and table-access. According to their names, each of them carries functions toward different fields. The arithmetic and relational metamethods are mostly responsible for binary operations, and the other two are often for tables and reserved functions. Generally, values in Lua can only take arithmetic and relational metamethods, since what they defined would not change the normal behavior of the programming language. On the other hand, table-access metamethods will possibly change the behavior of tables for several situations based on our research \cite{PIL}.

Figure \ref{fig:metatables and metamethods} introduces the metamethods that play key roles in FWLua. Figure \ref{fig:matatables} gives the type of each metamethod, and Figure~\ref{FW2.1metamethods} shows a default metatable in FWLua.

%One thing need to pay attention: library-defined metamethods may not be that necessary in FWLua since we don't think that it belongs to core work. Next, we will also show some instances for table-access metamethods since some of them would be very important for the further work.

% -------------------------------[FW2.1][METATABLES]-------------------------------
\begin{figure}[P]
\caption{Matatable Event Types}
{\bf Table-Access Metamethods}
\label{fig:matatables}
\[
\begin{array}{rclcl}
  {\tt \_\_index}(get) & :: & {table} ~\rightarrow ~ {string} ~\rightarrow ~ {value} \\
  {\tt \_\_newindex}(set)   & :: &  {table} ~\rightarrow ~{string} ~\rightarrow ~{value} ~\rightarrow ~{\tt nil}\\
\end{array}
\]

{\bf Arithmetic Metamethods}
\[
\begin{array}{rclcl}
  {\tt \_\_add(+)}   & :: &  {value} ~\rightarrow ~{value}~\rightarrow ~{value}\\
  {\tt \_\_sub(-)}   & :: &  {value} ~\rightarrow ~{value}~\rightarrow ~{value}\\
  {\tt \_\_mul(*)}   & :: &  {value} ~\rightarrow ~{value}~\rightarrow ~{value}\\
  {\tt \_\_div(/)}   & :: &  {value} ~\rightarrow ~{value}~\rightarrow ~{value}\\
  {\tt \_\_mod(mod)}   & :: &  {value} ~\rightarrow ~{value}~\rightarrow ~{value}\\
  {\tt \_\_pow({\wedge})}   & :: &  {value} ~\rightarrow ~{value}~\rightarrow ~{value}\\
\end{array}
\]

{\bf Relational Metamethods}
\[
\begin{array}{rclcl}
  {\tt \_\_eq(==)} & :: & {value} ~\rightarrow ~ {value} ~\rightarrow ~ {value}\\
  {\tt \_\_ne(\sim=)} & :: & {value} ~\rightarrow ~ {value} ~\rightarrow ~ {value}\\
  {\tt \_\_lt(<)}   & :: &  {value} ~\rightarrow ~{value} ~\rightarrow ~{value}\\
  {\tt \_\_le(<=)}   & :: &  {value} ~\rightarrow ~{value} ~\rightarrow ~{value}\\
  {\tt \_\_gt(>)}   & :: &  {value} ~\rightarrow ~{value} ~\rightarrow ~{value}\\
  {\tt \_\_ge(>=)}   & :: &  {value} ~\rightarrow ~{value} ~\rightarrow ~{value}\\
\end{array}
\]
\end{figure}

\newcommand{\aFunction}[2]{\lambda{#1}.{#2}}

% -------------------------------[FW2.1][METAMETHODS]---------------------------

\begin{figure}[P]
\caption{Definitions of Functions and Events}
{\bf Default Metatable}
\label{fig:FW2.1metamethods}
\[
\begin{array}{rclcl}
  {\tt \_\_index}  & \xlongequal[]{def} & \aFunction{T}{\aFunction{s}{\tt nil}}\\
  
  {\tt \_\_newindex} & \xlongequal[]{def}  & \aFunction{T}{\aFunction{s}{\aFunction{v}{{\tt rawset}(T,s,v)}}}\\
 {\tt \_\_add}   & \xlongequal[]{def}  & \aFunction{v_1}{\aFunction{v_2}{(v_1+v_2)}} \\
 {\tt \_\_sub}   & \xlongequal[]{def}  & \aFunction{v_1}{\aFunction{v_2}{(v_1-v_2)}} \\
 {\tt \_\_mul}   & \xlongequal[]{def}  & \aFunction{v_1}{\aFunction{v_2}{(v_1*v_2)}} \\
 {\tt \_\_div}   & \xlongequal[]{def}  & \aFunction{v_1}{\aFunction{v_2}{(v_1/v_2)}} \\
 {\tt \_\_mod}   & \xlongequal[]{def}  & \aFunction{v_1}{\aFunction{v_2}{(v_1~{\tt mod}~v_2)}} \\
 {\tt \_\_pow}   & \xlongequal[]{def}  & \aFunction{v_1}{\aFunction{v_2}{(v_1 \wedge v_2)}} \\
         
\end{array}
\]
\end{figure}
